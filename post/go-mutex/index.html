<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go Mutex - longtb site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="longtb" /><meta name="description" content="从问题入手： 如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex呢？ 在正常" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="http://longtb.cn/post/go-mutex/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go Mutex" />
<meta property="og:description" content="从问题入手： 如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex呢？ 在正常" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://longtb.cn/post/go-mutex/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-03-26T20:34:39+08:00" />
<meta property="article:modified_time" content="2023-03-26T20:34:39+08:00" />

<meta itemprop="name" content="Go Mutex">
<meta itemprop="description" content="从问题入手： 如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex呢？ 在正常"><meta itemprop="datePublished" content="2023-03-26T20:34:39+08:00" />
<meta itemprop="dateModified" content="2023-03-26T20:34:39+08:00" />
<meta itemprop="wordCount" content="3669">
<meta itemprop="keywords" content="mutex," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go Mutex"/>
<meta name="twitter:description" content="从问题入手： 如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex呢？ 在正常"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">longtb</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">longtb</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go Mutex</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-03-26 </span>
        <div class="post-category">
            <a href="/categories/go/"> go </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#版本更迭">版本更迭</a>
      <ul>
        <li><a href="#初版">初版</a></li>
        <li><a href="#第二版">第二版</a>
          <ul>
            <li><a href="#请求锁">请求锁</a></li>
            <li><a href="#释放锁">释放锁</a></li>
          </ul>
        </li>
        <li><a href="#第三版">第三版</a>
          <ul>
            <li><a href="#加锁逻辑">加锁逻辑</a></li>
          </ul>
        </li>
        <li><a href="#第四版">第四版</a></li>
        <li><a href="#java中的reentrantlock">Java中的ReentrantLock</a></li>
        <li><a href="#性能比较">性能比较</a></li>
        <li><a href="#实现方式比较">实现方式比较</a></li>
        <li><a href="#锁的特性比较">锁的特性比较</a></li>
        <li><a href="#最后">最后</a></li>
        <li><a href="#常见错误的四种场景">常见错误的四种场景</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>从问题入手：</p>
<blockquote>
<p>如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex呢？</p>
</blockquote>
<p>在正常状态下，所有等待锁的 goroutine 按照 FIFO 顺序等待。但是，刚唤醒（即出队）的 goroutine 不会直接拥有锁，而是会和新请求锁的
goroutine 去竞争锁。新请求锁的 goroutine 具有一个优势：它正在 CPU 上执行。
而且可能有好几个 goroutine 同时在新请求锁，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的
goroutine 在没有获得锁之后会加入到等待队列的最前面。</p>
<p>如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。</p>
<p>在饥饿模式下，锁的所有权将从执行 unlock 的 goroutine 直接交给等待队列中的第一个等待锁者。
新来的 goroutine 将不能再去尝试竞争锁，即使锁是 unlock 状态，也不会去尝试自旋操作，而是放在等待队列的尾部。</p>
<p>如果一个等待的 goroutine 获取了锁，并且满足以下其中一个条件：</p>
<ul>
<li>(1)它是队列中的最后一个；</li>
<li>(2)它等待的时候小于1ms，那么该 goroutine 会将锁的状态转换为正常状态。</li>
</ul>
<p>正常模式具有较好的性能，因为 goroutine 可以连续多次尝试获取锁，即使还有其他的阻塞等待锁的 goroutine，也不需要进入休眠阻塞。
饥饿模式也很重要的，它的作用是阻止尾部延迟的现象。</p>
<h1 id="版本更迭">版本更迭</h1>
<ul>
<li>初版: 使用一个flag字段标记是否持有锁</li>
<li>第二版: 新的goroutine也能有机会竞争锁</li>
<li>第三版: 新来的和被唤醒的有更多的机会竞争锁</li>
<li>第四版: 解决竞争问题，不会让goroutine等待太久</li>
</ul>
<h2 id="初版">初版</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// func cas(val *int32, old, new int32) bool
</span></span></span><span class="line"><span class="cl"><span class="c1">// func semacquire(*int32)
</span></span></span><span class="line"><span class="cl"><span class="c1">// func semrelease(*int32)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 互斥锁的结构，包含两个字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">key</span> <span class="kt">int32</span>  <span class="c1">// 锁是否被持有的标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sema</span> <span class="kt">int32</span> <span class="c1">// 信号量专用，用以阻塞/唤醒goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 保证成功在val上增加delta的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">xadd</span><span class="p">(</span><span class="nx">val</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">v</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">cas</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="o">+</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">v</span> <span class="o">+</span> <span class="nx">delta</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unreached&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 请求锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">//标识加1，如果等于1，成功获取到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span> <span class="c1">// 否则阻塞等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 将标识减去1，如果等于0，则没有其它等待者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span> <span class="c1">// 唤醒其它阻塞的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>CAS指令</strong>将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。</p>
</blockquote>
<p>由代码可知</p>
<ul>
<li><strong>字段key</strong>: 是一个 flag，用来标识这个排外锁是否被某个 goroutine 所持有，如果 key
大于等于 1，说明这个排外锁已经被持有；</li>
<li><strong>字段 sema</strong>: 是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒。</li>
</ul>
<p><img src="http://image.longtb.cn/20220527215810.png" alt="初版"></p>
<p><strong>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今</strong></p>
<h2 id="第二版">第二版</h2>
<p>Go 开发者在 2011 年 6 月 30 日的 commit 中对 Mutex 做了一次大的调整，调整后的
Mutex 实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sema</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// mutex is locked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mutexWoken</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="http://image.longtb.cn/20220527220005.png" alt="mutex第二版"></p>
<p>state 是一个复合型的字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。所以，state 这一个字段被分成了三部分，代表三个数据</p>
<h3 id="请求锁">请求锁</h3>
<p>请求锁代码也变的复杂</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Fast path: 幸运case，能够直接获取到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">		<span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span> <span class="p">|</span> <span class="nx">mutexLocked</span> <span class="c1">// 新状态加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">new</span> <span class="p">=</span> <span class="nx">old</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span> <span class="c1">//等待者数量加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// goroutine是被唤醒的，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// 新状态清除唤醒标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span><span class="c1">//设置新状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 锁原状态未加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">runtime</span><span class="p">.</span><span class="nf">Semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span> <span class="c1">// 请求信号量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其请求锁有以下几步</p>
<p>1）通过 CAS 检测 state 字段中的标志，如果没有goroutine持有锁，则直接获取锁；</p>
<p>2）state 不是零值，那么就通过一个循环进行检查，如果<code>atomic.CompareAndSwapInt32(&amp;m.state, old, new)</code> 能成功将state设置为新值，那么则表示抢夺锁成功，</p>
<p>但是需要注意的是，如果成功地设置了 state 的值，但是之前的 state 是有锁的状态， 那么，state 只是清除 mutexWoken 标志或者增加一个 waiter 而已。</p>
<p>请求锁的 goroutine 有两类，</p>
<ul>
<li>一类是新来请求锁的 goroutine</li>
<li>另一类是被唤醒的等待请求锁的goroutine。</li>
</ul>
<p>锁的状态也有两种：加锁和未加锁。</p>
<p>以下表格表示goroutine不同来源不同状态下的处理逻辑
<img src="http://image.longtb.cn/20220527222534.png" alt="不同来源不同状态"></p>
<h3 id="释放锁">释放锁</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Fast path: drop lock bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">new</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="o">-</span><span class="nx">mutexLocked</span><span class="p">)</span> <span class="c1">//去掉锁标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">new</span><span class="o">+</span><span class="nx">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">//本来就没有加锁 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">old</span> <span class="o">:=</span> <span class="nx">new</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">new</span> <span class="p">=</span> <span class="p">(</span><span class="nx">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">mutexWoken</span> <span class="c1">// 新状态，准备唤醒goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runtime</span><span class="p">.</span><span class="nf">Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样释放锁也有几个步骤</p>
<p>1)尝试将持有锁的标识设置为未加锁的状态，这是通过减 1 而不是将标志位置零的方式实现</p>
<p>2)通过信号量的方式唤醒等待这个锁的goroutine中的一个，其中涉及的逻辑又有两种情况</p>
<ul>
<li>如果没有其它的 waiter，说明对这个锁的竞争的 goroutine 只有一个，那就可以直接返回了</li>
<li>如果有等待者，并且没有唤醒的 aiter，那就需要唤醒一个等待的 waiter。在唤醒之前，需要将 waiter 数量减 1，并且将 mutexWoken 标志设置上</li>
</ul>
<h2 id="第三版">第三版</h2>
<p>在 2015 年 2 月的改动中，如果新来的 goroutine 或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑</p>
<h3 id="加锁逻辑">加锁逻辑</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Fast path: 幸运之路，正好获取到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="nx">iter</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">{</span> <span class="c1">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>            <span class="c1">// 先保存当前锁的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span> <span class="p">|</span> <span class="nx">mutexLocked</span>  <span class="c1">// 新状态设置加锁标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 锁还没被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="nf">runtime_canSpin</span><span class="p">(</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 还可以自旋
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">awoke</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span>
</span></span><span class="line"><span class="cl">                <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexWok</span>
</span></span><span class="line"><span class="cl">        <span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">runtime_doSpin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="nx">iter</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span> <span class="c1">// 自旋，再次尝试请求锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">new</span> <span class="p">=</span> <span class="nx">old</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span> <span class="c1">// 唤醒状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">new</span> <span class="o">&amp;</span> <span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span> <span class="c1">// 新状态清除唤醒标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">old</span> <span class="o">&amp;</span> <span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 旧状态锁已释放，新状态成功持有了锁，直接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span> <span class="c1">// 阻塞等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>                <span class="c1">// 被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">iter</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第四版">第四版</h2>
<p>经过几次优化，Mutex 的代码越来越复杂，应对高并发争抢锁的场景也更加公平。 但是极端情况下，等待中的 goroutine 可能会一直获取不到锁</p>
<p>Mutex 不能容忍这种事情发生。所以，2016 年 Go 1.9 中 Mutex 增加了饥饿模式，让锁 变得更公平，不公平的等待时间限制在 1 毫秒，并且修复了一个大 Bug：总是把唤醒的goroutine 放在等待队列的尾部，会导致更加不公平的等待时间</p>
<p>现在的 Mutex 代码已经复杂得接近不可读的状态了。</p>
<p><img src="http://image.longtb.cn/20220527223801.png" alt="第四版"></p>
<h2 id="java中的reentrantlock">Java中的ReentrantLock</h2>
<p>在Java中，ReentrantLock的实现是基于AbstractQueuedSynchronizer（AQS）的。它有两种状态：未锁定和锁定。当一个线程请求锁定时，如果当前没有被锁定，则它可以获得锁定并继续执行。如果已经被锁定，则请求锁定的线程就会进入阻塞状态，等待锁定被释放并唤醒它。</p>
<h2 id="性能比较">性能比较</h2>
<p>在性能方面，Go语言中的Mutex和Java中的ReentrantLock都是高效的锁。它们都允许多个goroutine或线程同时访问共享变量，而只有一个goroutine或线程可以修改变量。在单个goroutine或线程的情况下，Go语言中的Mutex比Java中的ReentrantLock稍快。但是，当涉及到多个goroutine或线程时，性能差异就会很小，因为它们的底层实现都依赖于操作系统的原语。</p>
<h2 id="实现方式比较">实现方式比较</h2>
<p>在实现方式方面，Go语言中的Mutex是基于操作系统提供的原语实现的，而Java中的ReentrantLock是基于AQS实现的。AQS提供了一些高级功能，例如可重入性、公平性和条件等待等。这些功能使ReentrantLock比Mutex更灵活和强大。</p>
<h2 id="锁的特性比较">锁的特性比较</h2>
<p>Go语言中的Mutex只有两种状态，即锁定和未锁定，而Java中的ReentrantLock则提供了许多特性，例如可重入性、公平性、超时等待、条件等待等。这些特性使ReentrantLock更加灵活和适应性更强。</p>
<p>总体而言，Go语言中的Mutex和Java中的ReentrantLock都是可靠和高效的锁，它们的底层实现都依赖于操作系统的原语。在选择哪种锁时，需要根据实际需求和场景来进行评估。如果只需要简单的锁定机制，则可以选择Go语言中的Mutex。如果需要更多的功能和特性，例如</p>
<h2 id="最后">最后</h2>
<ol>
<li>
<p>目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？</p>
<ul>
<li>前三个 bit 是 mutexLocked（锁标记）、mutexWoken（唤醒标记）、mutexStarving（饥饿标记）</li>
<li>剩余 bit 标示 mutexWaiter（等待数量）</li>
</ul>
</li>
<li>
<p>等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？
目前的设计来看取决于 state 的类型，目前是 uint32，由于3个字节代表了状态，还有： 2^(32 – 3) – 1 等于 536870911，
一个 goroutine 初始化的为 2kb, 536870911 &amp; 2kb 是相当大的数，所以可以满足现实的需求。</p>
</li>
</ol>
<h2 id="常见错误的四种场景">常见错误的四种场景</h2>
<p>Lock/Unlock 不是成对出现、Copy 已使用的 Mutex、重入和死锁。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">longtb</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-03-26
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/mutex/">mutex</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/go-slice/">
            <span class="next-text nav-default">go slice</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:longtb976@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/longtb976" class="iconfont icon-github" title="github"></a>
      <a href="https://space.bilibili.com/50071795" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://longtb.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2022 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>longtb</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
